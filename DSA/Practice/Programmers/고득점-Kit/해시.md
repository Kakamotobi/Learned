# 해시

## [완주하지 못한 선수](https://programmers.co.kr/learn/courses/30/lessons/42576)
- **Inputs**
  - An array of strings `participant` representing all participants of the marathon.
  - An array of strings `completion` representing the participants that completed the marathon.
- **Description**
  - Everyone completed the marathon except for one person.
- **Output:** return the name of the person that did not complete the marathon.
- **Constraints**
  - `1 <= participant.length <= 100,000`.
    - `1 <= participant[i].length <= 20`.
  - `completion.length === participant.length - 1`.
  - There can be participants that share the same name.
### Example
```js
solution(["leo","kiki","eden"], ["eden","kiki"]); // "leo"
solution(["marina","josipa","nikola","vinko","filipa"], ["josipa","filipa","marina","nikola"]); // "vinko"
solution(["mislav","stanko","mislav","ana"], ["stanko","ana","mislav"]); // "mislav"
```
### Solutions
#### Solution 1 - O(n)
- Use a hash table to store the number of times each name appear.
- Remove those that have completed the marathon.
- There should be only one person left in the hash table.
```js
const solution = (participant, completion) => {
  const obj = {};
  
  for (let p of participant) {
    obj[p] = ++obj[p] || 1;
  }
  
  for (let c of completion) {
    obj[c]--;
    if (obj[c] === 0) delete obj[c]; // To prevent iterations when finding the target.
  }
  
  // The only property left in obj is the person who did not complete the marathon.
  return Object.keys(obj)[0];
}
```
#### Solution 2 - O(n log n)
- Sort both arrays.
- Iterate through both arrays at the same time.
  - Return `participant[i]` when they are different.

## [전화번호 목록](https://programmers.co.kr/learn/courses/30/lessons/42577)
- **Input:** an array of strings `phone_book` representing phone numbers.
- **Output:** return false if a phone number is a prefix of another phone number. Otherwise, return true.
- **Constraints**
  - `1 <= phone_book.length <= 1,000,000`.
  - `1<= phone_book[i] <= 20`.
  - There are no duplicate numbers.
### Example
```js
solution(["119", "97674223", "1195524421"]); // false
solution(["123","456","789"]); // true
solution(["12","123","1235","567","88"]); // false
```
### Solution
- Sort the phone numbers in increasing order (so that similar phone numbers, if any, are adjacent of one another).
- Compare this phone number with the next phone number.
```js
const solution = (phone_book) => {
  phone_book.sort();

  for (let i = 0; i < phone_book.length - 1; i++) {
    if (phone_book[i+1].startsWith(phone_book[i])) return false;
  }
  return true;
}
```
