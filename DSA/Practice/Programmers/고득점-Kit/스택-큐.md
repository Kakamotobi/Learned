# 스택, 큐

## [기능개발](https://programmers.co.kr/learn/courses/30/lessons/42586#)
- **Inputs**
  - An array of natural numbers `progresses` representing the order of deployment for features.
    - `progresses[i]` represents the current progress of a feature.
  - An array of natural numbers `speeds` representing the speed of development (per day) for each feature, in the same order as `progresses`.
- **Description**
  - Preceding features need to be completed first before being deployed.
  - Ex: `[a,b,c]` even if task `c` is completed, tasks `a` and `b` have to be completed before it can get deployed.
- **Output:** in an array, return the number of features that is deployed per deployment.
- **Constraints**
  - `progresses.length <= 100`.
  - `speeds.length <= 100`.
  - `1 < progresses[i] < 100`.
  - `1 < speeds[i] <= 100`.
  - Only one deployment is allowed per day, at the end of the day.
### Example
```js
solution([93,30,55], [1,30,5]); // [2,1]
solution([95,90,99,99,80,99], [1,1,1,1,1,1]); // [1,3,2]
solution([95,95,95,95], [4,3,2,1]); // [2,1,1]
```
### Solution
- Loop through the queue `progresses`.
  - Calculate the number of days required for the current feature to complete.
  - Apply the days of progress to all features.
  - Find out how many features are completed and record it.
  - Move on to the next incomplete feature.
```js
const solution = (progresses, speeds) => {
  const answer = [];
  
  let i = 0;
  while (i < progresses.length) {
    const numDaysTo100 = Math.ceil((100 - progresses[i]) / speed[i]);
    
    for (let j = i; j < progresses.length; j++) {
      const progressMadeToday = progresses[j] + (speeds[j] * numDaysTo100);
      progresses[j] = progressMadeToday >= 100 ? 100 : progressMadeToday;
    }
    
    let temp = i;
    while (progresses[temp] === 100) temp++;
    answer.push(temp - i);
    i = temp;
  }
  
  return answer;
}
```

## [프린터](https://programmers.co.kr/learn/courses/30/lessons/42587)
- **Inputs**
  - An array of positive integers `priorities` representing the queue of documents waiting to be printed.
    - `priorities[i]` represents the priority number of the document.
    - The higher the number, the higher the priority.
  - A number `location` representing the current index (0-based) of the document that I requested to print.
- **Description**
  - If the first document has the highest priority, it is able to print.
  - If it is not the highest priority, it will be sent to the back of the queue.
- **Output:** return the order that my document will be printed.
- **Constraints**
  - `1 <= priorities.length <= 100`.
  - `1 <= priorities[i] <= 9`.
  - `0 <= location <= priorities.length - 1`.
### Example
```js
solution([2,1,3,2], 2); // 1
solution([1,1,9,1,1,1], 0); // 5
solution([2,3,3,2,9,3,3], 3); // 6
solution([3,3,4,2], 3); // 4
```
### Solution
- Keep track of the order by keeping a list of printed documents.
- Indicate starting indices of each document as a property to keep track of which is my document.
  - Ex: `[2,1,3,2]` &rarr; `[{ startIndex: 0, priority: 2 }, { startIndex: 1, priority: 1 }, { startIndex: 2, priority: 3 }, { startIndex: 4, priority: 2 }]`.
- Take the first document. 
  - If it has the highest priority,
    - "Print" it.
    - If it is my document, return its order.
  - Else, send to the back of the queue.
```js
const solution = (priorities, location) => {
  const printerQueue = priorities.map((priority, idx) => ({ startIndex: idx, priority }));
  const printed = [];
  
  while (true) {
    const highestPriority = Math.max(...printerQueue.map(doc => doc.priority));
    
    const firstDoc = printerQueue.shift();
    if (firstDoc.priority >= highestPriority) {
      printed.push(firstDoc);
      if (firstDoc.startIndex === location) break;
    } else {
      printerQueue.push(firstDoc);
    }
  }
  
  return printed.length;
}
```
