# 깊이, 너비 우선 탐색 (DFS, BFS)

## [타겟 넘버](https://programmers.co.kr/learn/courses/30/lessons/43165)
- **Inputs**
  - An array of positive integers `numbers`.
  - A positive integer `target`.
- **Description**
  - Use all numbers in `numbers.`
  - Each number can be added or subtracted.
- **Output:** return the number of ways that `target` can be achieved by adding or subtracting each number.
- **Constraints**
  - `2 <= numbers.length <= 20`.
  - `1 <= numbers[i] <= 50`.
  - `1 <= target <= 1,000`.
### Example
```js
solution([1,1,1,1,1], 3); // 5
solution([4,1,2,1], 4); // 2
```
### Solution
- Keep track of current number (using index) and the running sum.
```js
const solution = (numbers, target) => {
  let numWays = 0;
  
  const dfs = (idx, runningSum) => {
    if (idx === numbers.length) {
      if (runningSum === target) numWays++;
      return;
    }
    
    dfs(idx+1, runningSum + numbers[idx]);
    dfs(idx+1, runningSum - numbers[idx]);
  }
  
  dfs(0,0);
  
  return numWays;
}
```

## [네트워크](https://programmers.co.kr/learn/courses/30/lessons/43162)
- **Inputs**
  - A positive integer `n` representing the number of computers.
  - An array of arrays `computers` representing connection information between computers.
    - `computers[i][j] === 1` means there is a connection between computer `i` and computer `j`.
    - `computers[i][j] === 0` means there is no connection between computer `i` and computer `j`.
    - `computers[i][i]` is always 1 (computers are connected to themselves).
- **Output:** return the number of networks in the given set of computers.
- **Constraints**
  - `1 <= n <= 200` (natural number).
  - Each computer is expressed as integers from 0 to n - 1, inclusive.
### Example
```js
solution(3, [[1, 1, 0], [1, 1, 0], [0, 0, 1]]); // 2
solution(3, [[1, 1, 0], [1, 1, 1], [0, 1, 1]]); // 1
```
### Solution
- If the computer has not been visited already, traverse through the network starting from that computer.
```js
const solution = (n, computers) => {
  let numNetworks = 0;
  
  const visitedComputers = {};
  
  const traverseNetwork = (computer) => {
    if (computer in visitedComputers) return;
    
    visitedComputers[computer] = true;
    
    for (let i = 0; i < n; i++) {
      // If computer i has not been visited AND this computer has a connection with computer i.
      if (!(i in visitedComputers) && computers[computer][i] === 1) {
        traverseNetwork(i);
      }
    }
  }
  
  for (let i = 0; i < n; i++) {
    if (!(i in visitedComputers)) {
      newNetwork(i);
      numNetworks++;
    }
  }
  
  return numNetworks;
}
```
